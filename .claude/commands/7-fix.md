---
allowed-tools: >
  Bash(git branch:*),
  Bash(git checkout:*),
  Bash(git add:*),
  Bash(git commit:*),
  Bash(git log:*),
  Bash(git diff:*),
  Bash(echo:*),
  Bash(mkdir:*),
  Bash(cat:*),
  Bash(date:*),
  Write(*),
  Read(*),
  Glob(*),
  Grep(*),
  MultiEdit(*)
description: |
  バグ修正・機能修正コマンド。原因調査→ドキュメント更新→実装修正→再発防止の一連フローを実行。
  引数にIssue IDと修正指示を受け取る。
---

## 引数

$ARGUMENTS

## 概要

バグや機能不具合が発見された際に、**原因調査を起点**としてドキュメントを先に更新し、
その後に実装を修正する。最後に再発防止ドキュメントを残すことで、
同じミスの繰り返しを防ぐ。

## 実行手順 🤖

### 1. 引数検証と準備

- 第 1 引数で **Issue ID** を受け取る（必須）
- 第 2 引数以降で **修正指示・バグの症状** を受け取る（必須）
  - 例: `/7-fix 42 ログイン画面でメールアドレスのバリデーションが効いていない`
  - 例: `/7-fix 55 日記一覧のソート順が作成日時ではなく更新日時になっている`
- 引数が不足している場合はエラーメッセージを表示して終了
- 対象タスクの YAML ファイル `tasks/{Issue ID}_*.yaml` を確認

### 2. 機能ブランチの作成・切り替え

- 既存ブランチ `feature/implement-{Issue ID}` がある場合は切り替え
- 無い場合は最新の main ブランチから `fix/{Issue ID}-hotfix` で新規作成

### 3. 原因調査（Root Cause Analysis）

[ultrathink] 以下の手順で徹底的に原因を調査する:

1. **症状の特定**: 引数で渡された修正指示から、何が期待動作と異なるのかを整理
2. **関連コードの探索**: Grep/Glob を駆使して関連するソースファイルを特定
3. **コード読解**: 問題箇所のコードを読み、ロジックの流れを追跡
4. **根本原因の特定**: 単なる表面的な原因ではなく、なぜその問題が生まれたかの根本原因を特定
5. **影響範囲の調査**: 同じパターンが他の箇所にも存在しないか確認

### 4. 原因調査ドキュメント作成

`tasks/fix/` ディレクトリがなければ作成し、以下のドキュメントを生成:

**ファイル名**: `tasks/fix/{Issue_ID}_analysis.md`

```markdown
---
issue: {Issue ID}
title: "{修正タイトル}"
type: "bugfix" | "feature-fix"
severity: "critical" | "high" | "medium" | "low"
createdAt: "{ISO 8601}"
---

# 原因調査レポート

## 1. 症状・問題の概要
- 報告された症状
- 期待される動作
- 実際の動作

## 2. 影響範囲
- 影響を受ける機能
- 影響を受けるユーザー/シナリオ

## 3. 根本原因（Root Cause）
- 問題が発生しているファイル・行番号
- なぜこの問題が発生したか（技術的な原因）
- なぜ見逃されたか（プロセス上の原因）

## 4. 関連コード
- 問題箇所のコード抜粋と説明

## 5. 修正方針
- 修正アプローチの概要
- 修正による副作用リスク
- 代替案があれば記載
```

### 5. 要件定義・設計ドキュメントの更新

[ultrathink] 既存のドキュメントを確認し、**問題の原因となった記載漏れ・不整合**を修正する:

1. **設計ドキュメント確認**: `tasks/design/{Issue ID}_*.md` が存在すれば読み込み
2. **要件定義確認**: `docs/` 配下の関連する仕様書・要件定義を確認
3. **ドキュメント更新**:
   - 設計書に **「修正履歴」セクション** を追加（または追記）
   - 不足していた要件・制約・エッジケースを追記
   - バリデーションルール、ビジネスロジックの明確化
4. **更新内容をコンソールに表示**して、何を修正したか説明

> 重要: ドキュメントが存在しない場合は、必要最小限の設計ノートを
> `tasks/fix/{Issue_ID}_design_note.md` として新規作成する。

### 6. 実装の修正

[ultrathink] 原因調査と修正方針に基づいて実装を修正する:

1. **バグ修正コードの実装**
   - 根本原因に対する修正を実施
   - プロジェクト規約に従ったコーディング
2. **回帰テストの作成**
   - 今回のバグを再現するテストケースを作成（修正前なら失敗するテスト）
   - 修正後に正しく動作することを確認するテスト
   - 関連する既存テストへの影響がないことを確認
3. **テスト実行と品質チェック**
   - プロジェクトに応じたテストコマンドを実行
   - lint、型チェック等の品質チェック実行

### 7. 再発防止ドキュメント作成（Lessons Learned）

**ファイル名**: `tasks/fix/{Issue_ID}_lessons_learned.md`

このドキュメントは**次回同じミスを防ぐ**ための最重要成果物:

```markdown
---
issue: {Issue ID}
title: "{修正タイトル}"
createdAt: "{ISO 8601}"
relatedAnalysis: "tasks/fix/{Issue_ID}_analysis.md"
---

# 再発防止レポート（Lessons Learned）

## 1. 問題サマリー
- 何が起きたか（1-2 文）
- 根本原因（1-2 文）

## 2. なぜ発生したか（5 Whys）
1. Why: ...
2. Why: ...
3. Why: ...
4. Why: ...
5. Why: ...

## 3. 修正内容
- 変更したファイルと変更概要
- 追加したテスト

## 4. 再発防止チェックリスト
次回、同様の実装をする際にチェックすべき項目:
- [ ] チェック項目1
- [ ] チェック項目2
- [ ] チェック項目3

## 5. プロセス改善提案
- コードレビューで見るべきポイント
- テスト追加すべき観点
- ドキュメントに明記すべき制約

## 6. 関連する既知のリスク
- 同じパターンが存在する他の箇所（あれば）
```

### 8. 変更のコミット

- 不要なファイル（履歴ファイル等）は除外
- コミットメッセージは Conventional Commits 形式:
  - バグ修正: `fix: {修正内容の要約}`
  - 機能修正: `fix: {修正内容の要約}` or `refactor: {修正内容の要約}`
- ドキュメント更新のコミットは別にする:
  1. `docs: add root cause analysis for #{Issue ID}`
  2. `fix: {修正内容}` (コード変更)
  3. `docs: add lessons learned for #{Issue ID}`
- ローカルコミットのみ（プッシュしない）

### 9. PR 関連ファイル作成/更新

- `tasks/pr/commits` ディレクトリがなければ作成
- 今回の修正の差分を `tasks/pr/{Issue_ID}_commits/{YYYYMMDDHHMMSS}.md` に記録:
  - 原因調査の要約
  - 修正内容
  - 追加したテスト
  - 更新したドキュメント

### 10. タスクステータス更新

- YAML ファイルを更新:
  - `updatedAt` を現在時刻に更新
  - `fix` セクションを追加:
    - `analysis`: 原因調査ドキュメントパス
    - `lessonsLearned`: 再発防止ドキュメントパス
    - `branch`: ブランチ名
    - `commits`: コミットハッシュ一覧

### 11. 完了ログ出力

- 修正概要を表示
- 作成・更新したドキュメント一覧:
  - 原因調査レポート
  - 更新した設計ドキュメント
  - 再発防止レポート
- ブランチ名とコミット状況
- 次のステップ（`/5-update-pr` or `/6-push-pr`）への案内
