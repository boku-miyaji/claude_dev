---
allowed-tools: >
  Bash(git branch:*),
  Bash(git checkout:*),
  Bash(git add:*),
  Bash(git commit:*),
  Bash(git log:*),
  Bash(git diff:*),
  Bash(echo:*),
  Bash(mkdir:*),
  Bash(cat:*),
  Bash(date:*),
  Write(*),
  Read(*),
  Glob(*),
  Grep(*),
  MultiEdit(*)
description: |
  バグ修正・機能修正コマンド。原因調査→上流ドキュメント更新→実装修正の一連フローを実行。
  引数に修正指示を受け取る。
---

## 引数

$ARGUMENTS

## 概要

バグや機能不具合が発見された際に、**原因調査を起点**として上流ドキュメント（要件定義・設計書）を
先に正しく定義し直し、その後に実装を修正する。
上流のドキュメントが正確であれば、同じミスは自然と防げる。

## 実行手順 🤖

### 1. 引数検証と準備

- 引数で **修正指示・バグの症状** を受け取る（必須）
  - 例: `/fix ログイン画面でメールアドレスのバリデーションが効いていない`
  - 例: `/fix 日記一覧のソート順が作成日時ではなく更新日時になっている`
- 引数が空の場合はエラーメッセージを表示して終了
- タイムスタンプを生成: `YYYYMMDDHHMMSS`
- 修正指示から短い識別スラッグを生成（例: `email-validation`, `sort-order`）

### 2. 修正ブランチの作成・切り替え

- 最新の main ブランチから `fix/{slug}` で新規作成

### 3. 原因調査（Root Cause Analysis）

[ultrathink] 以下の手順で徹底的に原因を調査する:

1. **症状の特定**: 引数で渡された修正指示から、何が期待動作と異なるのかを整理
2. **関連コードの探索**: Grep/Glob を駆使して関連するソースファイルを特定
3. **コード読解**: 問題箇所のコードを読み、ロジックの流れを追跡
4. **根本原因の特定**: 単なる表面的な原因ではなく、なぜその問題が生まれたかの根本原因を特定
5. **影響範囲の調査**: 同じパターンが他の箇所にも存在しないか確認

### 4. 原因調査ドキュメント作成

`tasks/fix/` ディレクトリがなければ作成し、以下のドキュメントを生成:

**ファイル名**: `tasks/fix/{timestamp}_{slug}_analysis.md`

```markdown
---
title: "{修正タイトル}"
type: "bugfix" | "feature-fix"
severity: "critical" | "high" | "medium" | "low"
createdAt: "{ISO 8601}"
---

# 原因調査レポート

## 1. 症状・問題の概要
- 報告された症状
- 期待される動作
- 実際の動作

## 2. 影響範囲
- 影響を受ける機能
- 影響を受けるユーザー/シナリオ

## 3. 根本原因（Root Cause）
- 問題が発生しているファイル・行番号
- なぜこの問題が発生したか（技術的な原因）
- なぜ見逃されたか（プロセス上の原因）

## 4. 関連コード
- 問題箇所のコード抜粋と説明

## 5. 修正方針
- 修正アプローチの概要
- 修正による副作用リスク
- 代替案があれば記載
```

### 5. 要件定義・設計ドキュメントの更新

[ultrathink] これが最も重要なステップ。
上流ドキュメントが正確であれば同じ問題は自然と防げる。

1. **設計ドキュメント確認**: `tasks/design/` 配下の関連する設計書を確認
2. **要件定義確認**: `docs/` 配下の関連する仕様書・要件定義を確認
3. **課題の分類と対応方針の判断**:

   | 課題の種類 | 対応 |
   |---|---|
   | 要件の定義漏れ・曖昧さ | 要件定義書に正確な仕様を追記 |
   | 設計の不備・考慮不足 | 設計書にエッジケース・制約を追記 |
   | 局所的・実装レベルの問題 | 設計書内に `⚠️ 注意` として補足を追記 |

4. **ドキュメント更新の実施**:
   - 不足していた要件・仕様を正確に定義
   - 曖昧だったエッジケース・境界条件を明文化
   - バリデーションルール、ビジネスロジックの明確化
   - 局所的な問題の場合は、関連セクションに注意書きを追記する程度でよい
5. **更新内容をコンソールに表示**して、何をどう修正したか説明

> 重要: 関連する設計ドキュメントが存在しない場合は、
> 該当機能の設計書を `tasks/design/{slug}.md` として新規作成する。

### 6. 実装の修正

[ultrathink] 原因調査と更新したドキュメントの定義に基づいて実装を修正する:

1. **バグ修正コードの実装**
   - 根本原因に対する修正を実施
   - プロジェクト規約に従ったコーディング
2. **回帰テストの作成**
   - 今回のバグを再現するテストケースを作成（修正前なら失敗するテスト）
   - 修正後に正しく動作することを確認するテスト
   - 関連する既存テストへの影響がないことを確認
3. **テスト実行と品質チェック**
   - プロジェクトに応じたテストコマンドを実行
   - lint、型チェック等の品質チェック実行

### 7. 変更のコミット

- 不要なファイル（履歴ファイル等）は除外
- コミットメッセージは Conventional Commits 形式:
  - バグ修正: `fix: {修正内容の要約}`
  - 機能修正: `fix: {修正内容の要約}` or `refactor: {修正内容の要約}`
- ドキュメント更新とコード変更のコミットは分ける:
  1. `docs: update design/requirements for {slug}` (ドキュメント更新)
  2. `fix: {修正内容}` (コード変更 + テスト)
- ローカルコミットのみ（プッシュしない）

### 8. 完了ログ出力

- 修正概要を表示
- 作成・更新したドキュメント一覧
- ブランチ名とコミット状況
- 次のステップへの案内
